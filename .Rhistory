x[300]
x[3000]
x [c(-2, -10)]
x[-c(2, 10)]
vect <- c(foo = 11, bar = 1, norf = NA)
vect <- c(foo = 11, bar = 2, norf = NA)
vect
name(vect)
names(vect)
vect2 <- c(11,2,NA)
names(vect2) <- c("foo", "bar", "norf")
identical(vect,vect2)
vect["bar"]
vect[c("foo", "bar")]
my_vector <- 1:20
my_vector
dim(my_vector)
length(my_vector)
dim(my_vector <- c(4,5))
dim(my_vector) <- c(4,5))
dim(my_vector) <- c(4,5)
dimdd(my_vector)
dim(my_vector)
attributes(my_vector)
my_vector
class(my_vector)
my_matrix <- my_vector
?matrix()
?matrix
my_matrix2(1:20,4,5)
my_matrix <- c(1:20,4,5)
my_matrix <- matrix (1:20,4,5)
my_matrix <- matrix (data = 1:20,nrow = 4, ncol = 5)
my_matrix2 <- matrix (data = 1:20,nrow = 4, ncol = 5)
identical(my_matrix, my_matrix2)
patients <- c("Bill", "Gina", "Kelly", "Sean")
cbind(patients, my_matrix)
my_data <- data.frame(patients, my_matrix)
my_data
class(my_data)
cname <- c("patient", "age", "weight", "bp", "rating", "test")
cnames <- c("patient", "age", "weight", "bp", "rating", "test")
colnames(cnames, my_data)
?colnames
colnames(my_data, cnames)
colnames(my_data) <- cnames
my_data
setwd("C:/KK/GITFiles/Coursera/Rprogramming/A2/ProgrammingAssignment2")
?inverse
??inverse
?matrix
mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
dimnames = list(c("row1", "row2"),
c("C.1", "C.2", "C.3")))
mdat
mdat
??inverse
solve(mdat)
mdat <- matrix(c(1,2,3, 4,5,6, 7,8,9), nrow = 3, ncol = 3, byrow = TRUE,
dimnames = list(c("row1", "row2", "row3"),
c("C.1", "C.2", "C.3")))
mdat
solve(mdat)
mdat <- matrix(c(1,2,3, 4,5,6, 7,8,9))
mdat
mdat <- matrix(c(1,2,3, 4,5,6, 7,8,9), nrow = 3, ncol = 3, byrow = TRUE)
mdat
solve(mdat)
pd1 <- pdCompSymm(3 * diag(3) + 1)
pd1 <- pdMat(diag(1:4), pdClass = "pdDiag")
?solve()
mdat <- matrix(c(1,2,3, 4,5,6, 7,8,9), nrow = 3, ncol = 3, byrow = TRUE)
#     dimnames = list(c("row1", "row2", "row3"),
#                     c("C.1", "C.2", "C.3")))
#                     c("C.1", "C.2", "C.3")))
mdat
solve(mdat)
A <- hilbert(4)
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
#     dimnames = list(c("row1", "row2", "row3"),
#                     c("C.1", "C.2", "C.3")))
mdat
solve(mdat)
source('C:/KK/GITFiles/Coursera/Rprogramming/A2/ProgrammingAssignment2/cachematrix.R')
source('C:/KK/GITFiles/Coursera/Rprogramming/A2/ProgrammingAssignment2/cachematrix.R')
mcm <- makeCacheMatrix(mdat)
mcm
mcm <- cacheSolve(mdat)
x <- mdat
x
m <- x$getinverse()
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
source('~/.active-rstudio-document')
cm <- cachemean(c(1,2,3))
m <- mean(cm)
m <- mean(c(1,2,3))
m
getmean(m)
makevector()
makeVector()
makeVector(m)
> v <- c(1,2,4,5,6)
> mvo <- makeVector(v)
source('~/.active-rstudio-document')
> v <- c(1,2,4,5,6)
> mvo <- makeVector(v)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
v <- c(1,2,4,5,6)
mvo <- makeVector(v)
mvo
cachemean()
cachemean(mvo
)
v <- c(1,2,3)
cachemean(v)
makeVector(v)
cachemean(v)
mv  <- c(1,2,3)
makeVector(mv)
cachemean(mv)
mv  <- c(1,2,3)
> mvv <- makeVector(mv)
mvv <- makeVector(mv)
mvv
cachemean(mvv)
source('C:/KK/Coursera/RProgramming/Programs/testMatrix.R')
cacheSolve(a)
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
#     dimnames = list(c("row1", "row2", "row3"),
#                     c("C.1", "C.2", "C.3")))
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
#     dimnames = list(c("row1", "row2", "row3"),
#                     c("C.1", "C.2", "C.3")))
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
cacheSolve(mdat)
cacheSolce()
cacheSolve()
a<-makeCacheMatrix()
a$set(matrix(1:4,2,2)
)
cacheSolve(a)
a
cacheSolve(mdat)
mdat
a <- makeCacheMatrix(mdat)
a
cacheSolve(mdat)
cacheSolve(a)
a <- makeCacheMatrix()
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
#     dimnames = list(c("row1", "row2", "row3"),
#                     c("C.1", "C.2", "C.3")))
a<-makeCacheMatrix()
cacheSolve(A)
cacheSolve(a)
cacheSolve(mdat)
a$set(mdat)
a
cacheSolve(a)
a<-makeCacheMatrix()
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
set(matrix(1:4,2,2))
set<-function(y){
x<<-y
m<<-NULL
}
set(matrix(1:4,2,2))
a
m<-x$getmatrix()
m<-x$getmatrix(x)
a<-makeCacheMatrix()
a$set(matrix(1:4,2,2))
cacheSolve(a)
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
cacheSolve(a)
cacheSolve(a)
makeCacheMatrix <- function(x = matrix()) {
## create a special "matrix" object that can cache its inverse
m <- NULL
set <- function(y) {
x <<-y
m<<- NULL
}
get <- function () x
setinverse <- function(inverse) m <<-inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve function computes the inverse of the special "matrix" retruned by
## the makeCacheMatrix function. If inverse has been calculated (and matrix not
##  changed), the cacheSold function will retrieve inverse from cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!lis.nul(m)) {
message("getting cached data")
return(m)
}
data < x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
inv <- makeCacheMatrix()
inv$set(mdat)
cacheSolve(inv)
makeCacheMatrix <- function(x = matrix()) {
## create a special "matrix" object that can cache its inverse
m <- NULL
set <- function(y) {
x <<-y
m<<- NULL
}
get <- function () x
setinverse <- function(inverse) m <<-inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve function computes the inverse of the special "matrix" retruned by
## the makeCacheMatrix function. If inverse has been calculated (and matrix not
##  changed), the cacheSold function will retrieve inverse from cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data < x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
inv <- makeCacheMatrix()
env <- makeCacheMatrix()
inv <- set(mdat)
env$set(mdat)
ans <- cacheSolve(inv)
ans <- cacheSolve(env)
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
env <- makeCacheMatrix()
env$set(mdat)
ans <- cacheSolve(env)
ans
makeCacheMatrix <- function(x = matrix()) {
## create a special "matrix" object that can cache its inverse
m <- NULL
set <- function(y) {
x <<-y
m<<- NULL
}
get <- function () x
setinverse <- function(inverse) m <<-inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve function computes the inverse of the special "matrix" retruned by
## the makeCacheMatrix function. If inverse has been calculated (and matrix not
##  changed), the cacheSold function will retrieve inverse from cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data < x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
env <- makeCacheMatrix()
env$set(mdat)
ans <- cacheSolve(env)
ans
makeCacheMatrix <- function(x = matrix()) {
## create a special "matrix" object that can cache its inverse
m <- NULL
set <- function(y) {
x <<-y
m <<- NULL
}
get <- function () x
setinverse <- function(inverse) m <<-inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve function computes the inverse of the special "matrix" retruned by
## the makeCacheMatrix function. If inverse has been calculated (and matrix not
##  changed), the cacheSolve function will retrieve the inverse from cache and the
##  message 'getting cached data' is displayed.
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
mdata <- x$get()
m <- solve(mdata, ...)
x$setinverse(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
env <- makeCacheMatrix()
env$set(mdat)
ans <- cacheSolve(env)
ans
env <- makeCacheMatrix()
ans <- cacheSolve(env)
ans
env$set()
makeCacheMatrix <- function(x = matrix()) {
## create a special "matrix" object that can cache its inverse
m <- NULL
set <- function(y = matrix()) {
x <<-y
m <<- NULL
}
get <- function () x
setinverse <- function(inverse) m <<-inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve function computes the inverse of a matrix using the Solve() function.
## Function makeCacheMatrix is used to setup environment for this function.  If inverse
## has been calculated (and matrix not changed), the cacheSolve function will retrieve
## the inverse from cache and the message 'getting cached data' is displayed.
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
mdata <- x$get()
m <- solve(mdata, ...)
x$setinverse(m)
m
}
env <- makeCacheMatrix()
env$set()
ans <- cacheSolve()
makeCacheMatrix <- function(x = matrix()) {
## create a special "matrix" object that can cache its inverse
m <- NULL
set <- function(y) {
x <<-y
m <<- NULL
}
get <- function () x
setinverse <- function(inverse) m <<-inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve function computes the inverse of a matrix using the Solve() function.
## Function makeCacheMatrix is used to setup environment for this function.  If inverse
## has been calculated (and matrix not changed), the cacheSolve function will retrieve
## the inverse from cache and the message 'getting cached data' is displayed.
cacheSolve <- function(x = matrix(), ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
mdata <- x$get()
m <- solve(mdata, ...)
x$setinverse(m)
m
}
mdat <- matrix(c(1,0,4,1,3,4,4,1,0), nrow = 3, ncol = 3, byrow = TRUE)
env <- makeCacheMatrix()
env$set(mdat)
ans <- cacheSolve(env)
ans
solve(mdat)
